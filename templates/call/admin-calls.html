<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin Call Interface</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
      }

      .header {
        background: white;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .status {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
      }

      .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #ccc;
      }

      .status-indicator.connected {
        background: #22c55e;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .calls-section {
        background: white;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      h2 {
        margin-bottom: 15px;
        color: #333;
      }

      .calls-list {
        display: grid;
        gap: 10px;
      }

      .call-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 2px solid transparent;
        transition: all 0.3s;
      }

      .call-item:hover {
        border-color: #667eea;
        transform: translateY(-2px);
      }

      .call-item.pending-transfer {
        border-color: #fbbf24;
        background: #fef3c7;
      }

      .call-info {
        flex: 1;
      }

      .call-info strong {
        display: block;
        color: #333;
        margin-bottom: 5px;
      }

      .call-info small {
        color: #666;
      }

      .call-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
        margin-top: 5px;
      }

      .badge-ai {
        background: #dbeafe;
        color: #1e40af;
      }

      .badge-pending {
        background: #fef3c7;
        color: #92400e;
      }

      .join-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: background 0.3s;
      }

      .join-btn:hover:not(:disabled) {
        background: #5568d3;
      }

      .join-btn:disabled {
        background: #9ca3af;
        cursor: not-allowed;
      }

      .control-panel {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: none;
      }

      .control-panel.active {
        display: block;
      }

      .customer-info {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
      }

      .waiting-message {
        background: #fef3c7;
        border: 2px solid #fbbf24;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        text-align: center;
      }

      .waiting-message .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #fbbf24;
        border-top-color: transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-right: 10px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .controls {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .control-btn {
        padding: 12px 24px;
        border: none;
        border-radius: 6px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s;
      }

      .mute-btn {
        background: #fbbf24;
        color: white;
      }

      .mute-btn.muted {
        background: #ef4444;
      }

      .end-btn {
        background: #ef4444;
        color: white;
      }

      .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .audio-indicator {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin: 20px 0;
      }

      .indicator {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .indicator-circle {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: #e5e7eb;
        transition: all 0.3s;
      }

      .indicator-circle.speaking {
        background: #22c55e;
        box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        animation: speaking 0.5s ease-in-out infinite;
      }

      @keyframes speaking {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
      }

      .refresh-btn {
        background: #22c55e;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        margin-top: 15px;
      }

      .no-calls {
        text-align: center;
        color: #666;
        padding: 30px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="status">
          <div id="statusIndicator" class="status-indicator"></div>
          <span id="connectionStatus">Connecting...</span>
        </div>
      </div>

      <div class="calls-section">
        <h2>Active Calls</h2>
        <div id="callsList" class="calls-list">
          <div class="no-calls">Loading active calls...</div>
        </div>
        <button class="refresh-btn" onclick="loadActiveCalls()">
          üîÑ Refresh Calls
        </button>
      </div>

      <div id="controlPanel" class="control-panel">
        <h2>Call Control</h2>
        <div class="customer-info">
          <strong>Customer:</strong>
          <div>Name: <span id="customerName">-</span></div>
          <div>QID: <span id="customerQid">-</span></div>
        </div>

        <div id="waitingMessage" class="waiting-message" style="display: none">
          <div class="spinner"></div>
          <span>Transferring call... Please wait for customer to connect</span>
        </div>

        <div class="audio-indicator">
          <div class="indicator">
            <div id="customerIndicator" class="indicator-circle"></div>
            <small>Customer</small>
          </div>
          <div class="indicator">
            <div id="adminIndicator" class="indicator-circle"></div>
            <small>You</small>
          </div>
        </div>

        <div class="controls">
          <button
            id="muteBtn"
            class="control-btn mute-btn"
            onclick="toggleMute()"
          >
            üé§ Mute
          </button>
          <button class="control-btn end-btn" onclick="endCall()">
            ‚ùå End Call
          </button>
        </div>

        <div
          id="callStatus"
          style="text-align: center; margin-top: 15px; color: #666"
        >
          <small>Status: <span id="callState">Initializing...</span></small>
        </div>
      </div>
    </div>

    <script src="/static/twilio.min.js"></script>
    <script>
      let twilioDevice;
      let activeCall;
      let callSid = null;
      let audioContext;
      let analyser;
      let micStream;
      let remoteAnalyser;
      let animationFrame;
      let pollInterval;

      const SERVER_BASE_URL = "https://al-dar-call.go-globe.dev";

      async function initTwilioDevice() {
        try {
          const response = await fetch(`/call/token`);
          const data = await response.json();

          twilioDevice = new Twilio.Device(data.token, {
            codecPreferences: ["opus", "pcmu"],
            enableRingingState: true,
          });

          twilioDevice.on("registered", () => {
            console.log("‚úÖ Twilio Device registered");
            updateConnectionStatus("Connected", true);
            loadActiveCalls();
          });

          twilioDevice.on("error", (error) => {
            console.error("Twilio Device error:", error);
            updateConnectionStatus("Device Error", false);
          });

          await twilioDevice.register();
        } catch (error) {
          console.error("Failed to initialize Twilio Device:", error);
          updateConnectionStatus("Initialization Failed", false);
        }
      }

      function updateConnectionStatus(text, connected) {
        document.getElementById("connectionStatus").textContent = text;
        const indicator = document.getElementById("statusIndicator");
        if (connected) {
          indicator.classList.add("connected");
        } else {
          indicator.classList.remove("connected");
        }
      }

      async function loadActiveCalls() {
        try {
          const response = await fetch(`${SERVER_BASE_URL}/admin/active-calls`);
          const data = await response.json();
          displayActiveCalls(data.calls || []);
        } catch (error) {
          console.error("Failed to load active calls:", error);
        }
      }

      function displayActiveCalls(calls) {
        const listEl = document.getElementById("callsList");

        if (!calls || calls.length === 0) {
          listEl.innerHTML = '<div class="no-calls">No active calls</div>';
          return;
        }

        listEl.innerHTML = calls
          .map((call) => {
            const isPending = call.transfer_requested;
            const badgeClass = isPending ? "badge-pending" : "badge-ai";
            const badgeText = isPending ? "‚è≥ Transfer Pending" : "ü§ñ With AI";
            const itemClass = isPending
              ? "call-item pending-transfer"
              : "call-item";
            const btnDisabled = isPending ? "" : "";

            return `
                    <div class="${itemClass}">
                        <div class="call-info">
                            <strong>${call.customer_info?.name || "Unknown"}</strong>
                            <small>QID: ${call.customer_info?.qid || "N/A"}</small>
                            <div class="call-badge ${badgeClass}">${badgeText}</div>
                        </div>
                        <button class="join-btn" onclick="joinCall('${call.call_uuid}', '${call.call_sid}')" ${btnDisabled}>
                            ${isPending ? "üìû Answer" : "üëã Request Transfer"}
                        </button>
                    </div>
                `;
          })
          .join("");
      }

      async function joinCall(callUuid, twilioCallSid) {
        try {
          // First, request transfer from Gemini to admin
          const response = await fetch(
            `${SERVER_BASE_URL}/admin/request-transfer`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                call_uuid: callUuid,
                call_sid: twilioCallSid,
              }),
            },
          );

          const data = await response.json();

          if (data.success) {
            // Show waiting UI
            document.getElementById("controlPanel").classList.add("active");
            document.getElementById("customerName").textContent =
              data.customer_info?.name || "Unknown";
            document.getElementById("customerQid").textContent =
              data.customer_info?.qid || "Unknown";
            document.getElementById("waitingMessage").style.display = "block";
            document.getElementById("callState").textContent =
              "Transfer requested...";

            callSid = twilioCallSid;

            // Poll for call status
            startPollingCallStatus(callUuid);

            // Refresh the calls list to show pending state
            loadActiveCalls();
          } else {
            alert("Failed to request transfer: " + data.error);
          }
        } catch (error) {
          console.error("Failed to join call:", error);
          alert("Error: " + error.message);
        }
      }

      function startPollingCallStatus(callUuid) {
        if (pollInterval) clearInterval(pollInterval);

        pollInterval = setInterval(async () => {
          try {
            const response = await fetch(
              `${SERVER_BASE_URL}/admin/call-status/${callUuid}`,
            );
            const data = await response.json();

            if (data.status === "ready_for_admin") {
              // Call is ready, now connect via Twilio Device
              clearInterval(pollInterval);
              await connectToCall(callUuid);
            }
          } catch (error) {
            console.error("Error polling call status:", error);
          }
        }, 1000);
      }

      async function connectToCall(callUuid) {
        try {
          document.getElementById("callState").textContent = "Connecting...";

          activeCall = await twilioDevice.connect({
            params: {
              call_uuid: callUuid,
              admin_join: "true",
            },
          });

          activeCall.on("accept", () => {
            console.log("‚úÖ Connected to customer");
            document.getElementById("waitingMessage").style.display = "none";
            document.getElementById("callState").textContent = "Connected";
            startAudioVisualization();
          });

          activeCall.on("disconnect", () => {
            console.log("Call disconnected");
            handleCallEnd();
          });

          activeCall.on("error", (error) => {
            console.error("Call error:", error);
            alert("Call error: " + error.message);
            handleCallEnd();
          });
        } catch (error) {
          console.error("Failed to connect:", error);
          alert("Connection failed: " + error.message);
          handleCallEnd();
        }
      }

      function handleCallEnd() {
        if (pollInterval) {
          clearInterval(pollInterval);
          pollInterval = null;
        }

        stopAudioVisualization();
        document.getElementById("controlPanel").classList.remove("active");
        document.getElementById("waitingMessage").style.display = "none";
        activeCall = null;
        callSid = null;
        loadActiveCalls();
      }

      async function endCall() {
        if (activeCall) {
          activeCall.disconnect();
        }
        handleCallEnd();
      }

      function toggleMute() {
        if (activeCall) {
          const isMuted = activeCall.isMuted();
          activeCall.mute(!isMuted);

          const btn = document.getElementById("muteBtn");
          if (!isMuted) {
            btn.textContent = "üîá Unmute";
            btn.classList.add("muted");
          } else {
            btn.textContent = "üé§ Mute";
            btn.classList.remove("muted");
          }
        }
      }

      async function startAudioVisualization() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();

          // Get microphone input
          micStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          const micSource = audioContext.createMediaStreamSource(micStream);
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          micSource.connect(analyser);

          // Get remote audio
          if (activeCall && activeCall._mediaStream) {
            const remoteSource = audioContext.createMediaStreamSource(
              activeCall._mediaStream,
            );
            remoteAnalyser = audioContext.createAnalyser();
            remoteAnalyser.fftSize = 256;
            remoteSource.connect(remoteAnalyser);
          }

          animate();
        } catch (error) {
          console.warn("Audio visualization unavailable:", error);
        }
      }

      function animate() {
        animationFrame = requestAnimationFrame(animate);

        const micData = new Uint8Array(analyser.frequencyBinCount);
        analyser.getByteFrequencyData(micData);
        const micVolume =
          micData.reduce((a, b) => a + b, 0) / micData.length / 255;

        let remoteVolume = 0;
        if (remoteAnalyser) {
          const remoteData = new Uint8Array(remoteAnalyser.frequencyBinCount);
          remoteAnalyser.getByteFrequencyData(remoteData);
          remoteVolume =
            remoteData.reduce((a, b) => a + b, 0) / remoteData.length / 255;
        }

        const threshold = 0.1;
        const adminIndicator = document.getElementById("adminIndicator");
        const customerIndicator = document.getElementById("customerIndicator");

        if (micVolume > threshold) {
          adminIndicator.classList.add("speaking");
        } else {
          adminIndicator.classList.remove("speaking");
        }

        if (remoteVolume > threshold) {
          customerIndicator.classList.add("speaking");
        } else {
          customerIndicator.classList.remove("speaking");
        }
      }

      function stopAudioVisualization() {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
        if (micStream) {
          micStream.getTracks().forEach((track) => track.stop());
          micStream = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        analyser = null;
        remoteAnalyser = null;
      }

      // Initialize on load
      window.addEventListener("DOMContentLoaded", () => {
        initTwilioDevice();
        // Refresh calls every 5 seconds
        setInterval(loadActiveCalls, 5000);
      });

      window.addEventListener("beforeunload", () => {
        if (activeCall) {
          activeCall.disconnect();
        }
        stopAudioVisualization();
      });
    </script>
  </body>
</html>
