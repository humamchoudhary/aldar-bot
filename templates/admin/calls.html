{% extends 'admin/base.html' %}
{% block header %}
{{super()}}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
{% endblock %}

{% set title = "Calls" %} 
{% block content %}
<style>
.call-list-scroll::-webkit-scrollbar {
    width: 6px;
}

.call-list-scroll::-webkit-scrollbar-track {
    background: transparent;
}

.call-list-scroll::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}

.call-detail-scroll::-webkit-scrollbar {
    width: 6px;
}

.call-detail-scroll::-webkit-scrollbar-track {
    background: transparent;
}

.call-detail-scroll::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}
</style>

<div class="flex flex-col w-full h-full items-center justify-center">
    <div class="flex flex-row w-full min-h-[80vh]">
        <!-- Call List Section -->
        <div class="flex flex-col gap-[25px] {% if call %}w-1/3 min-w-[400px]{% else %}w-full{% endif %} h-[93vh] overflow-y-scroll call-list-scroll transition-all duration-300">
            <div class="flex flex-row gap-[32px] items-start justify-between mx-[24px] mt-[24px]">
                <p class="text-[18px] md:text-[26px] text-[var(--sec-text)]">Calls</p>
                
                <!-- Dropdown Filter -->
                <div class="relative" id="call-dropdown">
                    <button 
                        id="dropdown-button"
                        class="flex items-center justify-between px-[18px] py-[8px] bg-[var(--sec-bg-color)] border border-[var(--border-color)] rounded-md text-[14px] font-bold hover:cursor-pointer min-w-[150px]"
                        onclick="toggleDropdown()"
                    >
                        <span id="selected-option">All Calls <span id="selected-count">({{ call_counts.all or calls|length }})</span></span>
                        <svg class="w-4 h-4 ml-2 transition-transform duration-200" id="dropdown-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    
                    <div 
                        id="dropdown-menu"
                        class="absolute top-full left-0 mt-1 w-max bg-[var(--sec-bg-color)] border border-[var(--border-color)] rounded-md shadow-lg z-50 hidden"
                    >
                        <div 
                            hx-get="/admin/calls/all?page=0"
                            hx-target="#call_list_container"
                            hx-trigger="click"
                            hx-on:click="selectOption(this, 'All Calls', '{{ call_counts.all or calls|length }}')"
                            hx-indicator="#loading-indicator"
                            class="dropdown-option px-[18px] py-[8px] text-[14px] hover:bg-[var(--border-color)] cursor-pointer flex flex-row gap-2 flex-nowrap justify-between"
                            data-value="all"
                        >
                            All Calls <span class="float-right">({{ call_counts.all or calls|length }})</span>
                        </div>
                        
                        <div 
                            hx-get="/admin/calls/ongoing?page=0"
                            hx-target="#call_list_container"
                            hx-trigger="click"
                            hx-on:click="selectOption(this, 'Ongoing Calls', '{{ call_counts.ongoing or 0 }}')"
                            hx-indicator="#loading-indicator"
                            class="dropdown-option px-[18px] py-[8px] text-[14px] hover:bg-[var(--border-color)] cursor-pointer flex flex-row gap-2 flex-nowrap justify-between"
                            data-value="ongoing"
                        >
                            Ongoing Calls <span class="float-right">({{ call_counts.ongoing or 0 }})</span>
                        </div>
                        
                        <div 
                            hx-get="/admin/calls/ended?page=0"
                            hx-target="#call_list_container"
                            hx-trigger="click"
                            hx-on:click="selectOption(this, 'Ended Calls', '{{ call_counts.ended or 0 }}')"
                            hx-indicator="#loading-indicator"
                            class="dropdown-option px-[18px] py-[8px] text-[14px] hover:bg-[var(--border-color)] cursor-pointer flex flex-row gap-2 flex-nowrap justify-between"
                            data-value="ended"
                        >
                            Ended Calls <span class="float-right">({{ call_counts.ended or 0 }})</span>
                        </div>
                        
                        <div 
                            hx-get="/admin/calls/in_progress?page=0"
                            hx-target="#call_list_container"
                            hx-trigger="click"
                            hx-on:click="selectOption(this, 'In Progress Calls', '{{ call_counts.in_progress or 0 }}')"
                            hx-indicator="#loading-indicator"
                            class="dropdown-option px-[18px] py-[8px] text-[14px] hover:bg-[var(--border-color)] cursor-pointer flex flex-row gap-2 flex-nowrap justify-between"
                            data-value="in_progress"
                        >
                            In Progress Calls <span class="float-right">({{ call_counts.in_progress or 0 }})</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col" id="call_list_container">
                {% include 'components/call-list.html' %}
            </div>
        </div>
        
        <!-- Call Detail Section -->
        {% include "components/call.html" %}
    </div>
</div>

<script>
function toggleDropdown() {
    const dropdownMenu = document.getElementById('dropdown-menu');
    const dropdownIcon = document.getElementById('dropdown-icon');
    
    if (dropdownMenu.classList.contains('hidden')) {
        dropdownMenu.classList.remove('hidden');
        dropdownIcon.style.transform = 'rotate(180deg)';
    } else {
        dropdownMenu.classList.add('hidden');
        dropdownIcon.style.transform = 'rotate(0deg)';
    }
}

function selectOption(element, optionText, count) {
    const selectedOption = document.getElementById('selected-option');
    selectedOption.innerHTML = `${optionText} <span id="selected-count">(${count})</span>`;
    
    // Close dropdown
    document.getElementById('dropdown-menu').classList.add('hidden');
    document.getElementById('dropdown-icon').style.transform = 'rotate(0deg)';
    
    // Reset scroll position when switching options
    const callListContainer = document.getElementById('call_list_container');
    if (callListContainer) {
        callListContainer.scrollTop = 0;
    }
}

// Close dropdown when clicking outside
document.addEventListener('click', function(event) {
    const dropdown = document.getElementById('call-dropdown');
    if (!dropdown.contains(event.target)) {
        document.getElementById('dropdown-menu').classList.add('hidden');
        document.getElementById('dropdown-icon').style.transform = 'rotate(0deg)';
    }
});

function updateCallCounts() {
    fetch('/admin/call-counts')
        .then(response => response.json())
        .then(data => {
            const selectedCount = document.getElementById('selected-count');
            const selectedOption = document.getElementById('selected-option').textContent;
            
            if (selectedOption.includes('All Calls')) {
                selectedCount.textContent = `(${data.all})`;
            } else if (selectedOption.includes('Ongoing Calls')) {
                selectedCount.textContent = `(${data.ongoing})`;
            } else if (selectedOption.includes('Ended Calls')) {
                selectedCount.textContent = `(${data.ended})`;
            } else if (selectedOption.includes('In Progress Calls')) {
                selectedCount.textContent = `(${data.in_progress})`;
            }
            
            const dropdownOptions = document.querySelectorAll('.dropdown-option');
            dropdownOptions.forEach(option => {
                const value = option.getAttribute('data-value');
                const countSpan = option.querySelector('span');
                if (countSpan) {
                    switch(value) {
                        case 'all':
                            countSpan.textContent = `(${data.all})`;
                            break;
                        case 'ongoing':
                            countSpan.textContent = `(${data.ongoing})`;
                            break;
                        case 'ended':
                            countSpan.textContent = `(${data.ended})`;
                            break;
                        case 'in_progress':
                            countSpan.textContent = `(${data.in_progress})`;
                            break;
                    }
                }
            });
        })
        .catch(error => console.error('Error updating call counts:', error));
}

function enterCall(callId) {
    // Implement your call entry logic here
    console.log('Entering call:', callId);
    // You might want to open a new window, redirect, or trigger a WebRTC connection
    window.open(`/admin/call/${callId}/join`, '_blank');
}

function handleCallDelete(callId) {
    // Remove the call from the list
    const callItem = document.getElementById(`call-${callId}`);
    if (callItem) {
        callItem.remove();
    }
    
    // Hide the call detail area
    const callarea = document.getElementById('callarea');
    callarea.classList.add('hidden');
    callarea.innerHTML = '';
    
    // Update URL
    history.pushState({}, '', '/admin/calls');
    
    // Update counts
    updateCallCounts();
}

window.addEventListener("DOMContentLoaded", function () {
    const socket = io();

    socket.on("new_call", function (data) {
        htmx.ajax('GET', '/admin/calls_list/', '#call_list_container');
        updateCallCounts();
    });

    socket.on("call_status_change", function (data) {
        htmx.ajax('GET', '/admin/calls_list/', '#call_list_container');
        updateCallCounts();
        
        // Reload call detail if currently viewing the changed call
        const currentPath = window.location.pathname;
        if (currentPath.includes('/call/') && currentPath.includes(data.call_id)) {
            htmx.ajax('GET', currentPath, '#callarea');
        }
    });
});

document.body.addEventListener('htmx:afterSwap', (event) => {
    if (!event.detail.isOOBSwap && window.lucide) {
        lucide.createIcons();
    }
    
    const url = event.detail.pathInfo.requestPath;
    if (url.startsWith("/admin/call/")) {
        const callId = url.split("/").splice(-1)[0];
        const socket = io();

        socket.on("connect", function () {
            console.log('Socket connected for call:', callId);
            socket.emit("admin_join_call", { call_id: callId });
        });

        socket.on("new_message", function (data) {
            if (data.call_id === callId) {
                // Reload the call detail to show new transcription
                htmx.ajax('GET', `/admin/call/${callId}`, '#callarea');
            }
        });
    }
});

document.body.addEventListener("htmx:afterSwap", function (evt) {
    if (evt.detail.target.id === "callarea") {
        // Remove highlight class from all call rows
        document.querySelectorAll(".call-row").forEach(el => {
            el.classList.remove("bg-[var(--sec-bg-color)]");
        });

        // Get the new call ID from URL
        const callId = window.location.pathname.split("/").pop();
        
        const activeRow = document.getElementById("call-" + callId);
        if (activeRow) {
            activeRow.classList.add("bg-[var(--sec-bg-color)]");
        }
    }
});

function handleDeleteResponse(event, callId) {
    const status = event.detail.xhr.status;
    console.log('Delete response status:', status);

    const callItem = document.getElementById(`call-${callId}`);
    if (callItem) {
        callItem.remove();
    }

    updateCallCounts();

    if (window.location.pathname.includes(`/call/${callId}`)) {
        const callArea = document.getElementById('callarea');
        if (callArea) {
            callArea.classList.add('hidden');
            callArea.innerHTML = '';
        }
        history.pushState({}, '', '/admin/calls');
    }

    if (status === 203) {
        const url = event.detail.xhr.responseText.trim();
        console.log('Redirecting to:', url);

        history.pushState({}, '', url);
        htmx.ajax('GET', url, {
            target: '#callarea',
            swap: 'innerHTML',
        });
    }
}


let adminWs = null;
let serverBaseUrl = '';
let activeCallUuid = null;
let audioContext = null;
let mediaStream = null;
let isMuted = false;



function connectToServer() {
    const serverUrl = null;
    serverBaseUrl = serverUrl.replace('ws://', 'http://').replace('wss://', 'https://');
    
    // Connect WebSocket
    adminWs = new WebSocket(serverUrl + '/admin');
    
    adminWs.onopen = () => {
        console.log('âœ… Connected to server');
        document.getElementById('connectionStatus').textContent = 'âœ… Connected';
        loadActiveCalls();
    };
    
    adminWs.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleServerMessage(data);
    };
    
    adminWs.onerror = (error) => {
        console.error('Connection error:', error);
        document.getElementById('connectionStatus').textContent = 'âŒ Error';
    };
    
    adminWs.onclose = () => {
        document.getElementById('connectionStatus').textContent = 'ðŸ”Œ Disconnected';
    };
}




function handleServerMessage(data) {
    switch(data.type) {
            
        case 'takeover_success':
            console.log('âœ… Takeover successful');
            activeCallUuid = data.call_uuid;
            document.getElementById('customerName').textContent = 
                data.customer_info.name || 'Unknown';
            document.getElementById('callControl').style.display = 'block';
            break;
            
        case 'customer_audio':
            // Customer is speaking - you receive their audio here
            playCustomerAudio(data.audio);
            break;
            
        case 'takeover_ended':
            console.log('Call returned to AI');
            cleanupCall();
            break;
            
        case 'error':
            alert('Error: ' + data.message);
            break;
    }
}


async function joinCall(callUuid) {
    try {
        // Get microphone access
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Setup audio processing
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(mediaStream);
        const processor = audioContext.createScriptProcessor(4096, 1, 1);
        
        source.connect(processor);
        processor.connect(audioContext.destination);
        
        // Send admin audio to server
        processor.onaudioprocess = (e) => {
            if (!isMuted && adminWs && adminWs.readyState === WebSocket.OPEN) {
                const inputData = e.inputBuffer.getChannelData(0);
                const pcm16 = convertFloat32ToPCM16(inputData);
                const base64Audio = arrayBufferToBase64(pcm16);
                
                adminWs.send(JSON.stringify({
                    type: 'admin_audio',
                    audio: base64Audio
                }));
            }
        };
        
        // Send join request to server
        adminWs.send(JSON.stringify({
            action: 'join_call',
            call_uuid: callUuid
        }));
        
    } catch (error) {
        console.error('Failed to join call:', error);
        alert('Microphone access required: ' + error.message);
    }
}

// End takeover and return to AI
function endTakeover() {
    if (adminWs && activeCallUuid) {
        adminWs.send(JSON.stringify({
            type: 'end_takeover'
        }));
    }
    cleanupCall();
}

// Toggle mute
function toggleMute() {
    isMuted = !isMuted;
    console.log(isMuted ? 'ðŸ”‡ Muted' : 'ðŸ”Š Unmuted');
}

// Cleanup after call ends
function cleanupCall() {
    if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
    }
    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }
    activeCallUuid = null;
    isMuted = false;
    document.getElementById('callControl').style.display = 'none';
    loadActiveCalls(); // Refresh list
}

// Play customer audio (optional - if you want to hear customer)
function playCustomerAudio(base64Audio) {
    console.log('Received customer audio');

    // 1. Create an AudioContext (or reuse an existing one)
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    // 2. Decode the base64 string back into binary data (ArrayBuffer)
    // Assumes the base64 string represents binary audio data (e.g., from a WAV/MP3 file)
    const audioData = atob(base64Audio);
    const bufferLength = audioData.length;
    const arrayBuffer = new ArrayBuffer(bufferLength);
    const view = new Uint8Array(arrayBuffer);

    for (let i = 0; i < bufferLength; i++) {
        view[i] = audioData.charCodeAt(i);
    }

    // 3. Decode the audio data into an AudioBuffer
    audioContext.decodeAudioData(arrayBuffer,
        (audioBuffer) => {
            // Success callback
            console.log('Audio decoded successfully.');

            // 4. Create a source node
            const source = audioContext.createBufferSource();

            // 5. Set the buffer for the source
            source.buffer = audioBuffer;

            // 6. Connect the source to the speakers (destination)
            source.connect(audioContext.destination);

            // 7. Start playing the audio immediately
            source.start(0); // Start at time 0
        },
        (e) => {
            // Error callback
            console.error("Error decoding audio data:", e);
        }
    );
}

// Audio conversion helpers
function convertFloat32ToPCM16(float32Array) {
    const pcm16 = new Int16Array(float32Array.length);
    for (let i = 0; i < float32Array.length; i++) {
        const s = Math.max(-1, Math.min(1, float32Array[i]));
        pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return pcm16.buffer;
}

function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}




</script>

{% endblock %}
